---
phase: 01-scanner-source
plan: 02
type: execute
---

<objective>
Wire up source classification in the scanner orchestrator, implement local-vs-remote diff for synced repos, and add unit tests for the new logic.

Purpose: This plan connects the new types and enhanced fetching (from plan 01) to the scanner pipeline, and adds the git diff comparison that surfaces divergence between local and remote copies.
Output: Updated scanner/index.ts with source classification and diff computation, new scanner/diff.ts module, updated tests.
</objective>

<execution_context>
@~/.claude/skills/create-plans/workflows/execute-phase.md
@~/.claude/skills/create-plans/templates/summary.md
</execution_context>

<context>
@.planning/BRIEF.md
@.planning/ROADMAP.md
@.planning/phases/01-scanner-source/01-01-SUMMARY.md
@scanner/types.ts
@scanner/github.ts
@scanner/index.ts
@scanner/local.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create diff module for local-vs-remote comparison</name>
  <files>scanner/diff.ts</files>
  <action>
  Create a new module `scanner/diff.ts` that computes the local-vs-remote diff for synced repos.

  Export a function `computeLocalRemoteDiff(localPath: string, remoteBranches: string[], defaultBranch: string): Promise<LocalRemoteDiff>`.

  Implementation:
  1. Get current local branch: `git -C {localPath} rev-parse --abbrev-ref HEAD`
  2. Fetch latest remote state: `git -C {localPath} fetch origin --quiet` (wrap in try/catch — if no remote configured, return a diff with all zeros)
  3. Get ahead/behind counts: `git -C {localPath} rev-list --left-right --count HEAD...origin/{defaultBranch}` — parse output as "ahead\tbehind"
  4. Check for uncommitted changes: `git -C {localPath} status --porcelain` — non-empty means uncommitted changes
  5. Get local branches: `git -C {localPath} branch --format='%(refname:short)'`
  6. Compare local branches vs remoteBranches param to compute localOnlyBranches and remoteOnlyBranches

  Use `child_process.execSync` (or `execFileSync` for safety) for git commands. Wrap each in try/catch — any failure should gracefully return a LocalRemoteDiff with sensible defaults (zeros, empty arrays).

  Do NOT use `exec` (async callback-based) — use `execFileSync` to avoid shell injection and keep it simple.
  </action>
  <verify>npx tsc --noEmit on scanner/diff.ts shows no type errors</verify>
  <done>computeLocalRemoteDiff function exported, handles all git operations with graceful error handling, returns LocalRemoteDiff</done>
</task>

<task type="auto">
  <name>Task 2: Update scanner orchestrator with source classification and diff integration</name>
  <files>scanner/index.ts</files>
  <action>
  Update the main scanner loop in `scanner/index.ts`:

  1. Import `computeLocalRemoteDiff` from `./diff` and `fetchRepoLanguages` from `./github`.

  2. After determining `localPath`, classify source:
     - `localPath && repo.githubUrl` → `'synced'`
     - `localPath && !repo.githubUrl` → `'local-only'` (shouldn't happen since we start from GitHub repos, but handle it)
     - `!localPath` → `'remote-only'`

  3. For synced repos: call `computeLocalRemoteDiff(localPath, branchNames, repo.defaultBranch)` where `branchNames` comes from the GitHub API (already fetched). Note: the current code only gets `branchCount` not branch names. Update the branches fetch in github.ts to also return branch name strings — or fetch them here. Simpler: pass the branch names from a new `fetchBranchNames()` call, or modify the existing branches call in github.ts to return names. Choose the least disruptive approach: add an optional `fetchBranchNames(octokit, owner, repo)` function to github.ts that returns `string[]`.

  4. For all projects: populate the new fields in the Project object:
     - `source` — computed above
     - `visibility` — from `repo.visibility`
     - `languages` — from `repo.languages`
     - `topics` — from `repo.topics`
     - `license` — from `repo.license`
     - `sizeKB` — from `repo.sizeKB`
     - `isArchived` — from `repo.isArchived`
     - `isFork` — from `repo.isFork`
     - `diff` — from `computeLocalRemoteDiff()` result for synced repos, null otherwise

  5. Add `fetchBranchNames()` to `scanner/github.ts`: `async function fetchBranchNames(octokit, owner, repo): Promise<string[]>` — calls `octokit.repos.listBranches()` and returns `data.map(b => b.name)`. This replaces the current `.then(r => r.data.length)` approach for the branches call. Instead, fetch full branch data, extract both count and names.
  </action>
  <verify>npx tsc --noEmit succeeds with no errors across the scanner directory</verify>
  <done>Scanner classifies every project as local-only/remote-only/synced, synced repos get diff data, all projects have enhanced GitHub metadata populated</done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for source classification and diff logic</name>
  <files>scanner/__tests__/diff.test.ts, scanner/__tests__/source.test.ts</files>
  <action>
  Create `scanner/__tests__/diff.test.ts`:
  - Test `computeLocalRemoteDiff()` with mocked execFileSync (use vi.mock('child_process'))
  - Test cases:
    1. Normal synced repo: ahead 2, behind 1, clean working tree, some local-only and remote-only branches
    2. Repo with uncommitted changes
    3. Repo with no remote configured (fetch fails gracefully)
    4. Repo where git commands fail entirely (returns safe defaults)

  Create `scanner/__tests__/source.test.ts`:
  - Test source classification logic (extract to a helper if needed for testability):
    1. `localPath` exists + `githubUrl` exists → 'synced'
    2. `localPath` is null → 'remote-only'
    3. Edge: localPath exists + no githubUrl → 'local-only'

  Use Vitest (already configured in the project). Match existing test patterns in `scanner/__tests__/`.
  </action>
  <verify>npx vitest run scanner/__tests__/diff.test.ts scanner/__tests__/source.test.ts</verify>
  <done>All tests pass. Diff logic and source classification have test coverage for happy paths and error cases.</done>
</task>

</tasks>

<verification>
Before declaring this plan complete:
- [ ] `npx tsc --noEmit` succeeds
- [ ] `npx vitest run` passes all tests (existing + new)
- [ ] Source classification works for all three cases
- [ ] Diff computation handles error cases gracefully
</verification>

<success_criteria>
- Scanner classifies every project as local-only, remote-only, or synced
- Synced repos get ahead/behind counts, uncommitted changes flag, branch divergence
- All new scanner logic has unit test coverage
- Existing tests still pass
- Phase 01 complete
</success_criteria>

<output>
After completion, create `.planning/phases/01-scanner-source/01-02-SUMMARY.md`
</output>
